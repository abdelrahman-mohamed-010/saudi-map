<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Saudi Arabia Map Animation</title>
    <style>
      body {
          margin: 0;
          display: flex;
          justify-content: center;
          align-items: center;
          min-height: 100vh;
      }
      /* Replace canvas styles with mapContainer styles */
      #mapContainer {
          display: block;
          border: 2px solid #000;
          border-radius: 10px;
          position: relative;
          width: 600px;
          height: 600px;
          rotate: 180deg;
          transform: rotateY(180deg); /* Add this line to reverse the element */
         
      }
      /* Add styles for animated points */
      .map-point {
          position: absolute;
          width: 7px;
          height: 7px;
          border-radius: 50%;
          background-color: rgba(34, 197, 94, 1);
          /* Make transitions faster */
          transition: all 0.05s ease-out;
      }
      
      .hover-zone {
          position: absolute;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          pointer-events: all;
          z-index: 1;
      }

      .map-point.hovered {
          transform: scale(1.5);
          background-color: rgba(22, 163, 74, 1);
      }
    </style>
  </head>
  <body>
    <!-- Replace canvas with div -->
    <div id="mapContainer"></div>

    <script>
      const saudiCoordinates = [];

      fetch('./sa (1).json')
          .then(response => response.json())
          .then(data => {
              const coordinates = data.features[0].geometry.coordinates[0][0];
              const bounds = getBounds(coordinates);
              saudiCoordinates.push(...coordinates.map(coord => [
                  (coord[0] - bounds.minX) / (bounds.maxX - bounds.minX),
                  (coord[1] - bounds.minY) / (bounds.maxY - bounds.minY)
              ]));
              new SaudiMap();
          });

      function getBounds(coords) {
          const bounds = {
              minX: Infinity,
              maxX: -Infinity,
              minY: Infinity,
              maxY: -Infinity
          };

          coords.forEach(coord => {
              bounds.minX = Math.min(bounds.minX, coord[0]);
              bounds.maxX = Math.max(bounds.maxX, coord[0]);
              bounds.minY = Math.min(bounds.minY, coord[1]);
              bounds.maxY = Math.max(bounds.maxY, coord[1]);
          });

          const padding = 0.1;
          const rangeX = bounds.maxX - bounds.minX;
          const rangeY = bounds.maxY - bounds.minY;
          bounds.minX -= rangeX * padding;
          bounds.maxX += rangeX * padding;
          bounds.minY -= rangeY * padding;
          bounds.maxY += rangeY * padding;

          return bounds;
      }

      class SaudiMap {
          constructor() {
              this.container = document.getElementById('mapContainer');

              this.scale = 0.95;
              this.margin = 0.02;

              this.points = [];
              this.dotSize = 28;
              this.fadeSpeed = 0.08;
              this.density = 12;
              this.animationId = null;
              this.hoverZones = [];
              this.zoneSize = 27; // Slightly smaller zone for better response
              this.pointsMap = new Map(); // Add this line for optimization

              this.initPoints();
              this.setupHoverZones();
              this.animate();
          }

          isInsideSaudi(x, y, width, height) {
              let inside = false;
              let j = saudiCoordinates.length - 1;

              const effectiveSize = Math.min(width, height) * this.scale;
              const offsetX = (width - effectiveSize) / 2;
              const offsetY = (height - effectiveSize) / 2;

              for (let i = 0; i < saudiCoordinates.length; i++) {
                  const xi = saudiCoordinates[i][0] * effectiveSize + offsetX;
                  const yi = saudiCoordinates[i][1] * effectiveSize + offsetY;
                  const xj = saudiCoordinates[j][0] * effectiveSize + offsetX;
                  const yj = saudiCoordinates[j][1] * effectiveSize + offsetY;

                  const intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
                  if (intersect) inside = !inside;
                  j = i;
              }

              return inside;
          }

          initPoints() {
              const width = this.container.clientWidth;
              const height = this.container.clientHeight;
              this.points = [];
              const spacing = this.density;
              const offset = spacing / 2;

              for (let y = 0; y < height; y += spacing) {
                  for (let x = (y / spacing) % 2 === 0 ? 0 : offset; x < width; x += spacing) {
                      if (this.isInsideSaudi(x, y, width, height)) {
                          // Arrange dots in a staggered grid pattern
                          const pointElement = document.createElement('div');
                          pointElement.classList.add('map-point');
                          pointElement.style.left = `${x}px`;
                          pointElement.style.top = `${y}px`;
                          pointElement.style.opacity = Math.random();
                          this.container.appendChild(pointElement);

                          // Store points in a grid-based map for faster lookup
                          const gridX = Math.floor(x / this.zoneSize);
                          const gridY = Math.floor(y / this.zoneSize);
                          const key = `${gridX},${gridY}`;
                          if (!this.pointsMap.has(key)) {
                              this.pointsMap.set(key, []);
                          }
                          this.pointsMap.get(key).push({
                              element: pointElement,
                              x: x,
                              y: y,
                              opacity: parseFloat(pointElement.style.opacity),
                              targetOpacity: Math.random(),
                              transitionSpeed: 0.01 + Math.random() * 0.02
                          });
                          
                          this.points.push(this.pointsMap.get(key).at(-1));
                      }
                  }
              }
          }

          setupHoverZones() {
              const width = this.container.clientWidth;
              const height = this.container.clientHeight;
              const zoneSpacing = this.zoneSize;

              for (let y = 0; y < height; y += zoneSpacing) {
                  for (let x = 0; x < width; x += zoneSpacing) {
                      const zone = document.createElement('div');
                      zone.classList.add('hover-zone');
                      zone.style.left = `${x - this.zoneSize/2}px`;
                      zone.style.top = `${y - this.zoneSize/2}px`;
                      
                      // Replace mouseenter and mouseleave with mousemove
                      zone.addEventListener('mousemove', (event) => {
                          const rect = zone.getBoundingClientRect();
                          const mouseX = event.clientX - rect.left;
                          const mouseY = event.clientY - rect.top;
                          
                          const zoneCenterX = x;
                          const zoneCenterY = y;
                          
                          // Clear previously hovered points
                          this.points.forEach(point => {
                              point.element.classList.remove('hovered');
                          });

                          // Check surrounding grid cells
                          for (let dx = -1; dx <= 1; dx++) {
                              for (let dy = -1; dy <= 1; dy++) {
                                  const key = `${Math.floor((x + dx * this.zoneSize) / this.zoneSize)},${Math.floor((y + dy * this.zoneSize) / this.zoneSize)}`;
                                  const points = this.pointsMap.get(key);
                                  if (points) {
                                      points.forEach(point => {
                                          if (this.isPointInZone(point.x, point.y, x, y)) {
                                              point.element.classList.add('hovered');
                                          }
                                      });
                                  }
                              }
                          }
                      });

                      // Optionally handle mouseleave to clear hovered points
                      zone.addEventListener('mouseleave', () => {
                          this.points.forEach(point => {
                              point.element.classList.remove('hovered');
                          });
                      });

                      this.container.appendChild(zone);
                      this.hoverZones.push(zone);
                  }
              }
          }

          isPointInZone(pointX, pointY, zoneX, zoneY) {
              const distance = Math.sqrt(
                  Math.pow(pointX - zoneX, 2) + 
                  Math.pow(pointY - zoneY, 2)
              );
              return distance <= this.zoneSize/2;
          }

          animate() {
              this.points.forEach(point => {
                  if (Math.abs(point.opacity - point.targetOpacity) < 0.01) {
                      point.targetOpacity = Math.random();
                  }

                  point.opacity += (point.targetOpacity - point.opacity) * point.transitionSpeed * this.fadeSpeed;
                  point.element.style.opacity = point.opacity;
              });

              this.animationId = requestAnimationFrame(() => this.animate());
          }
      }
    </script>
  </body>
</html>
